<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Processes ELI5 &#8212; BEAM VM Wisdoms</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Process Heaps ELI5" href="eli5-process-heap.html" />
    <link rel="prev" title="Atoms ELI5" href="eli5-atoms.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
<section id="processes-eli5">
<h1>Processes ELI5<a class="headerlink" href="#processes-eli5" title="Permalink to this heading">¶</a></h1>
<p>This is a high level overview for how processes are made and how they work.</p>
<section id="general-overview">
<h2>General overview<a class="headerlink" href="#general-overview" title="Permalink to this heading">¶</a></h2>
<p>A process is a simple C structure, which contains
a <a class="reference internal" href="definitions.html#def-heap"><span class="std std-ref">heap</span></a>,
a <a class="reference internal" href="definitions.html#def-stack"><span class="std std-ref">stack</span></a>,
<a class="reference internal" href="definitions.html#def-registers"><span class="std std-ref">registers</span></a>,
and an instruction pointer. Also, there are some extra fields for exception
handling, tracing etc. A new process is this structure created with a minimal
size heap.</p>
<section id="spawning-a-new-process-actor">
<h3>Spawning a new Process (Actor)<a class="headerlink" href="#spawning-a-new-process-actor" title="Permalink to this heading">¶</a></h3>
<p>When you call <cite>spawn</cite> or <cite>spawn_link</cite>, the VM allocates a small piece of memory
with a new process header (approx 200-300 bytes) and the {heap with the stack}
(they live together and take about 1kb initially). A new process is granted a
new unique PID, which won’t repeat for a fair amount of days or months after its
death, and is registered in a process lookup table.</p>
<p>There are no messages involved in process creation only a couple of memory
allocations.</p>
<p>So the newly created process is not known to any scheduler yet. It is then
placed into a run queue for its priority (99.99% of processes run as normal),
where one of schedulers is able to pick it up and begin executing. Newer
versions of Erlang have run queues one per scheduler, but the principle is
the same.</p>
</section>
<section id="stack">
<h3>Stack<a class="headerlink" href="#stack" title="Permalink to this heading">¶</a></h3>
<a class="reference internal image-reference" href="_images/eli5-process-stack.png"><img alt="_images/eli5-process-stack.png" class="align-right" src="_images/eli5-process-stack.png" style="width: 300px;" /></a>
<p><a class="reference internal" href="definitions.html#def-stack"><span class="std std-ref">Stack</span></a> is an array of memory on the young heap used as return
stack and temporary storage for variables. Stack begins at the end of the heap
and grows back (downwards).
The data on stack is grouped into <a class="reference internal" href="definitions.html#def-stack-frame"><span class="std std-ref">Stack Frames</span></a>.</p>
<p>When a function needs some temporary memory, it allocates several words on the
stack and marks the 0-th word with special CP value. Later it can be used
as return address and to find out where next stack frame begins. This temporary
memory is also used to preserve registers during recursive calls (thus growing
the stack).</p>
<p>Tail-recursive calls avoid keeping this temporary data or free it before
recursing. They pass arguments in a smarter way that does not require saving
them on stack and does not grow it.</p>
</section>
<section id="execution">
<h3>Execution<a class="headerlink" href="#execution" title="Permalink to this heading">¶</a></h3>
<p>Every new process is assigned to a <a class="reference internal" href="definitions.html#def-scheduler"><span class="std std-ref">Scheduler</span></a>.
Scheduler picks one process from the queue and takes its instruction pointer.
Then scheduler executes one instruction and loops. After certain amount of work
done (<a class="reference internal" href="definitions.html#def-reduction"><span class="std std-ref">reductions</span></a>) scheduler will place the current
process to the back of the queue and select another one. This allows some sort
of fair scheduling: every process gets CPU time no matter how busy were other
processes in the queue.</p>
</section>
<section id="killing-and-exiting">
<h3>Killing and Exiting<a class="headerlink" href="#killing-and-exiting" title="Permalink to this heading">¶</a></h3>
<p>Killing a process is like sending it an exit exception. The process wakes up
from sleep, receives CPU time, and discovers an exception. Then it will either
<a class="reference internal" href="definitions.html#def-terminate"><span class="std std-ref">terminate</span></a> or catch the exception and process it like
a regular value. An unconditional <code class="docutils literal notranslate"><span class="pre">kill</span></code> signal works similarly except that
Erlang code cannot catch it.</p>
</section>
</section>
<section id="scheduling-and-load-balancing">
<h2>Scheduling and Load balancing<a class="headerlink" href="#scheduling-and-load-balancing" title="Permalink to this heading">¶</a></h2>
<a class="reference internal image-reference" href="_images/eli5-process-sched.png"><img alt="_images/eli5-process-sched.png" class="align-right" src="_images/eli5-process-sched.png" style="width: 300px;" /></a>
<p>By default BEAM VM starts one Erlang scheduler per CPU core. Processes get a
scheduler assigned to them in some manner (for simplicity you can say it is
random). You can configure schedulers using flags <code class="docutils literal notranslate"><span class="pre">+S</span></code> and <code class="docutils literal notranslate"><span class="pre">+SP</span></code>. Schedulers
can be bound to cores in different ways (<code class="docutils literal notranslate"><span class="pre">+sbt</span></code> flag).</p>
<p>There are 4 process priorities: low, normal, high and max.
Process at max always runs first making everything else wait.
High runs approximately 8 times much often than normal (the number
is implementation dependent).
Low runs when there is no other work to do.</p>
<p>At runtime schedulers will compare their process queue with the other (namely
the previous one in scheduler array). If the other queue is longer, the
scheduler will steal one or more processes from it. This is the default
behaviour which can be changed. The balancing strategy and can be configured
with VM flags <code class="docutils literal notranslate"><span class="pre">+S</span></code> and <code class="docutils literal notranslate"><span class="pre">+scl</span></code>. You could want to use as few cores as
possible to let other CPU cores sleep and save energy. Or you could prefer
equal spread of processes to cut the latency.</p>
<p>Stealing is as easy as moving a pointer from one array to another. This may
affect <a class="reference internal" href="definitions.html#def-cache-locality"><span class="std std-ref">cache locality</span></a> when an active process
jumps CPU core.</p>
</section>
<section id="process-registry">
<h2>Process Registry<a class="headerlink" href="#process-registry" title="Permalink to this heading">¶</a></h2>
<p>A global process table maps process identifier (pid) to a Process structure.
To know a pid of a process, refer to its <code class="docutils literal notranslate"><span class="pre">Process.common.id</span></code> field. A process
is uniquely identified by its local pid. Remote pids contain more information:
a node name and internal node id. Remote pids have to be resolved on the node
which owns them.</p>
<p>Another global table (process registry) maps names to pid. You can reach it
from Erlang by using <code class="docutils literal notranslate"><span class="pre">erlang:register</span></code>, <code class="docutils literal notranslate"><span class="pre">erlang:unregister</span></code> and
<code class="docutils literal notranslate"><span class="pre">erlang:whereis</span></code> BIFs.</p>
</section>
<section id="message-queues">
<h2>Message Queues<a class="headerlink" href="#message-queues" title="Permalink to this heading">¶</a></h2>
<a class="reference internal image-reference" href="_images/eli5-process-mqueue.png"><img alt="_images/eli5-process-mqueue.png" class="align-right" src="_images/eli5-process-mqueue.png" style="width: 300px;" /></a>
<p>Messages are stored on the heap or in heap fragments, and are chained together
using a single linked list. Message queue is a C structure which belongs in
Process struct and it contains <a class="reference internal" href="definitions.html#def-term"><span class="std std-ref">Terms</span></a> sent to the process.
<a class="reference internal" href="definitions.html#def-box"><span class="std std-ref">Boxed data</span></a> for larger or nested terms is located on the heap.
A pointer to position in the queue exists, and it is advanced with BEAM
opcodes which scan the mailbox.
When scan pointer reaches the end of the mailbox, the process is put to
receive sleep.
The pointer is reset to the beginning of the queue only if a message was matched.
This is why selective receive on large mailbox queues is slow.</p>
<section id="sending-a-message">
<h3>Sending a Message<a class="headerlink" href="#sending-a-message" title="Permalink to this heading">¶</a></h3>
<p>Sending a message to a process is simple — this is how VM does it:</p>
<ol class="arabic simple">
<li><p>Lock the process mailbox (or don’t, if running on a single core).</p></li>
<li><p>Copy message to destination process heap.</p></li>
<li><p>Add the resulting term to process mailbox.</p></li>
<li><p>Unlock the mailbox.</p></li>
<li><p>If the process was sleeping in a receive, it would return back to
scheduling queue and wake up when possible.</p></li>
</ol>
<p>A process waiting for a message (in receive operator) is never queued for
execution until a message arrives. This is why millions of idle processes can
exist on a single machine without it breaking a sweat.</p>
</section>
</section>
<section id="traps">
<h2>Traps<a class="headerlink" href="#traps" title="Permalink to this heading">¶</a></h2>
<p>Traps are a feature of the VM loop which allow to interrupt long running BIFs
temporarily. State is saved in temporary memory block and control returns to
the scheduler. Process sets its instruction pointer to the special trap
instruction and the BIF returns.</p>
<p>During the trap the current process is placed to the back of the process queue
which allows other processes to run. When the time comes again, the VM loop
encounters the trap instruction and jumps back to the long running BIF.</p>
</section>
</section>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-84125230-1', 'auto');
ga('send', 'pageview');
</script>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div style="margin-bottom:16px;">
    <a href="http://beam-wisdoms.clau.se/" alt="Wisdoms Home Page"
    title="Return to the Home Page"><img src="_static/img/bw_logo.png" width="200"></a>
</div>


<h1 class="logo"><a href="index.html">BEAM VM Wisdoms</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="eli5-vm.html">BEAM VM ELI5</a></li>
<li class="toctree-l1"><a class="reference internal" href="eli5-atoms.html">Atoms ELI5</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Processes ELI5</a></li>
<li class="toctree-l1"><a class="reference internal" href="eli5-process-heap.html">Process Heaps ELI5</a></li>
<li class="toctree-l1"><a class="reference internal" href="eli5-io.html">Input/Output and Ports ELI5</a></li>
<li class="toctree-l1"><a class="reference internal" href="eli5-tracing.html">Tracing ELI5</a></li>
<li class="toctree-l1"><a class="reference internal" href="eli5-bif-nif.html">BIF and NIF functions ELI5</a></li>
<li class="toctree-l1"><a class="reference internal" href="eli5-types.html">Types ELI5</a></li>
<li class="toctree-l1"><a class="reference internal" href="eli5-etf.html">External Term Format ELI5</a></li>
<li class="toctree-l1"><a class="reference internal" href="eli5-property-based.html">Property Based Testing ELI5</a></li>
<li class="toctree-l1"><a class="reference internal" href="eli5-efficiency.html">Efficiency ELI5</a></li>
<li class="toctree-l1"><a class="reference internal" href="eli5-efficiency-memory-perf.html">Memory Performance ELI5</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="definitions.html">BEAM Definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="indepth-memory-layout.html">Data Types Memory Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="indepth-data-sizes.html">BEAM Internal data sizes</a></li>
<li class="toctree-l1"><a class="reference internal" href="indepth-heap-layout.html">Process Heap Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="interfacing.html">Interfacing Erlang with the Outer World</a></li>
<li class="toctree-l1"><a class="reference internal" href="indepth-beam-file.html">BEAM File Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="indepth-beam-instructions.html">BEAM Instruction Codes</a></li>
<li class="toctree-l1"><a class="reference internal" href="indepth-io.html">IO in Erlang</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="eli5-atoms.html" title="previous chapter">Atoms ELI5</a></li>
      <li>Next: <a href="eli5-process-heap.html" title="next chapter">Process Heaps ELI5</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016-2017, Dmytro "kvakvs" Lytovchenko.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/eli5-processes.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>